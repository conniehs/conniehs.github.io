<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>RolePlayConvo: Interactive Conversation Practice</title>
<style>
  :root{
    --deep-1:#1f0b3a;
    --deep-2:#3b0f6f;
    --indigo:#4b0082;
    --coral:#ff6f61;
    --muted:#f5f5f7;
    --card:#ffffff;
    --glass: rgba(255,255,255,0.06);
    --accent:#7c3aed;
    --shadow: 0 8px 24px rgba(11,7,23,0.45);
    --radius:14px;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  body{
    background: linear-gradient(135deg,var(--indigo), #2e0854 70%);
    color: #fff;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    display:flex;
    flex-direction:column;
    min-height:100vh;
  }

  /* Header / Hero */
  .hero{
    padding:48px 20px;
    text-align:center;
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    backdrop-filter: blur(6px);
  }
  .hero-inner{
    max-width:980px;margin:0 auto;
  }
  h1{font-size:clamp(1.6rem,3.6vw,2.6rem);margin:0 0 12px 0;line-height:1.05;font-weight:700;color:#fff;}
  p.lead{margin:0 auto 18px auto;color:rgba(255,255,255,0.92);max-width:820px;font-size:1rem;}
  .hero-cta{margin-top:18px;display:flex;gap:14px;justify-content:center;flex-wrap:wrap;}
  .btn{
    background:linear-gradient(180deg,var(--coral), #ff5a4a);
    color:#fff;border:0;padding:14px 22px;border-radius:12px;font-weight:600;
    box-shadow: 0 6px 18px rgba(255,111,97,0.18);
    cursor:pointer;transition:transform .18s ease, box-shadow .18s ease;
    touch-action:manipulation;
  }
  .btn:active{transform:translateY(1px) scale(.997);}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.12);box-shadow:none;}

  /* Layout */
  .container{max-width:1100px;margin:28px auto;padding:0 18px;flex:1;}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:20px;}
  @media(max-width:980px){ .grid{grid-template-columns:1fr;} }

  /* Card */
  .card{
    background: linear-gradient(180deg,var(--muted), #ffffff);
    color:#222;border-radius:var(--radius);padding:18px;box-shadow:var(--shadow);
  }
  .card h2{margin:0 0 10px 0;color:var(--indigo);font-size:1.1rem;}
  label{display:block;font-size:0.9rem;margin-top:10px;color:#444;}
  input[type="text"], select, textarea{
    width:100%;padding:10px;border-radius:8px;border:1px solid #e6e6ea;font-size:0.95rem;margin-top:6px;
    resize:vertical;background:#fff;color:#222;
  }
  textarea{min-height:120px;max-height:320px;}

  /* Recording Studio */
  .studio{
    display:flex;flex-direction:column;align-items:center;gap:12px;
  }
  #micBig{
    width:120px;height:120px;border-radius:999px;background:linear-gradient(180deg,#fff,#ffecec);display:flex;align-items:center;justify-content:center;
    color:var(--indigo);font-size:36px;font-weight:700;border:none;box-shadow:0 10px 30px rgba(0,0,0,0.25);cursor:pointer;
    transition:transform .18s ease, box-shadow .18s ease;
  }
  #micBig.recording{transform:scale(0.98);box-shadow:0 6px 18px rgba(0,0,0,0.35);background:linear-gradient(180deg,#fff6f6,#ffdede);color:#b00000;}
  .status{font-size:0.95rem;color:#333;margin-top:6px;}
  .controls{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:8px;}
  .control-btn{background:transparent;border:1px solid rgba(0,0,0,0.06);padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600;color:var(--indigo);}
  .control-btn.primary{background:var(--coral);color:#fff;border:0;box-shadow:0 8px 20px rgba(255,111,97,0.12);}
  .small{font-size:0.9rem;padding:6px 10px;border-radius:8px;}

  /* Waveform */
  #waveCanvas{width:100%;height:96px;border-radius:8px;background:linear-gradient(180deg,#f3f4f6,#ffffff);display:block;}

  /* Analysis */
  .analysis-block{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-start;}
  .analysis-card{flex:1;min-width:220px;background:#fff;padding:12px;border-radius:10px;color:#222;}
  .analysis-card h3{margin:0 0 8px 0;font-size:0.95rem;color:var(--indigo);}
  .word{display:inline-block;padding:6px 8px;margin:6px 6px 0 0;border-radius:8px;background:#f3f4f6;color:#333;cursor:pointer;transition:transform .12s;}
  .word:hover{transform:translateY(-3px);box-shadow:0 6px 18px rgba(0,0,0,0.06);}

  /* Library */
  .library-list{display:flex;flex-direction:column;gap:10px;}
  .lib-item{display:flex;align-items:center;justify-content:space-between;padding:10px;border-radius:10px;background:#fff;color:#222;}
  .lib-meta{display:flex;gap:12px;align-items:center;flex-wrap:wrap;}
  .lib-actions{display:flex;gap:8px;align-items:center;}
  .pill{background:rgba(0,0,0,0.04);padding:6px 8px;border-radius:8px;font-weight:600;color:#333;font-size:0.85rem;}

  /* Footer small */
  .muted{color:rgba(0,0,0,0.55);font-size:0.9rem;}

  /* Animations */
  .fade-in{animation:fadeIn .45s ease both;}
  @keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:none}}

  /* Mobile friendly touches */
  @media (max-width:520px){
    #micBig{width:96px;height:96px;font-size:28px;}
    .controls{gap:6px}
    .btn{padding:12px 16px;border-radius:10px}
  }
</style>
</head>
<body>

<!-- HERO -->
<section class="hero">
  <div class="hero-inner">
    <h1>Welcome to RolePlayConvo! Enhance your speaking skills through engaging conversations.</h1>
    <p class="lead">Upload your conversation scripts, record your practice sessions, and get instant AI feedback on your pronunciation accuracy.</p>
    <div class="hero-cta">
      <button class="btn" id="startBtn">Start New Conversation</button>
      <button class="btn" id="viewLibBtn">View My Recordings</button>
    </div>
  </div>
</section>

<!-- MAIN -->
<main class="container">
  <div class="grid">

    <!-- LEFT: Script + Recording + Analysis -->
    <div style="display:flex;flex-direction:column;gap:18px;">

      <!-- SCRIPT UPLOAD -->
      <div class="card fade-in" id="scriptCard" aria-live="polite">
        <h2>Script Upload & Preview</h2>
        <label>Upload your conversation script (.txt)</label>
        <input type="file" id="fileInput" accept=".txt" />
        <label>Or paste / type your script below</label>
        <input type="text" id="scriptTitle" placeholder="Script title (e.g., Ordering Food)" />
        <label>Difficulty</label>
        <select id="difficulty">
          <option>Beginner</option>
          <option>Intermediate</option>
          <option>Advanced</option>
        </select>
        <label>Speaker roles (comma-separated, e.g., Student A, Student B)</label>
        <input type="text" id="rolesInput" placeholder="Student A, Student B" />
        <label>Script content (include lines for each speaker)</label>
        <textarea id="scriptText" placeholder="Example:
Student A: Hi, how are you?
Student B: I'm good, thanks. How about you?
..."></textarea>
        <div style="display:flex;gap:10px;align-items:center;margin-top:10px;">
          <button class="btn" id="saveScriptBtn">Save Script & Continue</button>
          <div id="scriptSavedMsg" class="muted" aria-hidden="true"></div>
        </div>
      </div>

      <!-- RECORDING STUDIO -->
      <div class="card fade-in" id="studioCard">
        <h2>Recording Studio</h2>
        <div class="studio">
          <button id="micBig" aria-pressed="false" title="Start / Stop recording">ðŸŽ¤</button>
          <div class="status" id="micStatus">Allow microphone access</div>

          <canvas id="waveCanvas" aria-hidden="true"></canvas>

          <div class="controls" style="margin-top:6px;">
            <button class="control-btn small" id="markA">Mark Speaker A</button>
            <button class="control-btn small" id="markB">Mark Speaker B</button>
            <button class="control-btn small" id="reRecord">Re-record</button>
            <button class="control-btn small" id="playRec">Play</button>
            <button class="control-btn small" id="downloadRec">Download</button>
            <button class="control-btn primary small" id="analyzeBtn">Analyse</button>
          </div>

          <div style="display:flex;gap:12px;margin-top:8px;flex-wrap:wrap;justify-content:center;">
            <div class="pill" id="timer">00:00</div>
            <div class="pill" id="currentSpeaker">Current: â€”</div>
            <div class="pill" id="recSize">0 KB</div>
          </div>

          <div style="margin-top:10px;color:#444;font-size:0.9rem;max-width:720px;text-align:center;">
            <em>Tip: While recording, tap "Mark Speaker A" or "Mark Speaker B" to label each speaker's segment. Speech recognition runs live and collects transcripts per speaker for analysis.</em>
          </div>
        </div>
      </div>

      <!-- PRONUNCIATION ANALYSIS -->
      <div class="card fade-in" id="analysisCard">
        <h2>Pronunciation Analysis</h2>
        <div class="analysis-block">
          <div class="analysis-card" id="analysisA">
            <h3>Student A</h3>
            <div id="scoreA">â€”</div>
            <div id="missA" style="margin-top:8px"></div>
          </div>
          <div class="analysis-card" id="analysisB">
            <h3>Student B</h3>
            <div id="scoreB">â€”</div>
            <div id="missB" style="margin-top:8px"></div>
          </div>
          <div class="analysis-card" id="analysisCombined">
            <h3>Combined</h3>
            <div id="scoreCombined" style="font-size:1.6rem;font-weight:700">â€”</div>
            <div style="margin-top:8px;color:#666;font-size:0.95rem">Click any highlighted word to hear correct UK pronunciation.</div>
          </div>
        </div>
      </div>

    </div>

    <!-- RIGHT: Library -->
    <aside>
      <div class="card fade-in" id="libraryCard">
        <h2>Recordings Library</h2>
        <div id="libraryList" class="library-list" aria-live="polite"></div>
        <div style="margin-top:12px;color:#666;font-size:0.9rem">All sessions persist locally in your browser (LocalStorage).</div>
      </div>
    </aside>

  </div>
</main>

<script>
/* ============================
   RolePlayConvo - Single File
   Features:
   - Script upload / paste / preview / save
   - Recording with WebAudio + waveform
   - Live SpeechRecognition during recording, segmented by speaker (A/B)
   - Pronunciation analysis comparing transcripts to script lines
   - TTS (UK) for word playback
   - Library persisted in localStorage with base64 audio
   - Responsive + touch-friendly controls
   ============================ */

/* ---------- Utilities ---------- */
const $ = id => document.getElementById(id);
const formatTime = s => {
  s = Math.floor(s);
  const mm = String(Math.floor(s/60)).padStart(2,'0');
  const ss = String(s%60).padStart(2,'0');
  return `${mm}:${ss}`;
};

/* ---------- Script handling ---------- */
let savedScript = null; // {title,difficulty,roles:[...],linesByRole:{A:[],B:[]},raw}
$('fileInput').addEventListener('change', e=>{
  const f = e.target.files[0];
  if(!f) return;
  const r = new FileReader();
  r.onload = () => $('scriptText').value = r.result;
  r.readAsText(f);
});

$('saveScriptBtn').addEventListener('click', ()=>{
  const raw = $('scriptText').value.trim();
  if(!raw){ alert('Please paste or upload a script first.'); return; }
  const title = $('scriptTitle').value.trim() || 'Untitled Script';
  const difficulty = $('difficulty').value;
  const rolesRaw = $('rolesInput').value.trim() || 'Student A, Student B';
  const roles = rolesRaw.split(',').map(s=>s.trim()).filter(Boolean);
  // Parse script lines: try to detect "Role: text" lines; otherwise split by lines and alternate
  const lines = raw.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  const linesByRole = {};
  roles.forEach((r)=>linesByRole[r]=[]);
  // If lines start with "Role:" pattern, assign accordingly
  let patternDetected = lines.every(l => /^[^:]{1,30}:\s*/.test(l));
  if(patternDetected){
    lines.forEach(l=>{
      const idx = l.indexOf(':');
      const role = l.slice(0,idx).trim();
      const text = l.slice(idx+1).trim();
      if(linesByRole[role] !== undefined) linesByRole[role].push(text);
      else {
        // unknown role: assign to first role
        linesByRole[roles[0]].push(text);
      }
    });
  } else {
    // alternate assignment across roles
    let ri = 0;
    lines.forEach(l=>{
      const role = roles[ri % roles.length];
      linesByRole[role].push(l);
      ri++;
    });
  }
  savedScript = {title,difficulty,roles,linesByRole,raw};
  $('scriptSavedMsg').innerText = 'Script saved! Ready for recording.';
  $('scriptSavedMsg').setAttribute('aria-hidden','false');
  // scroll to studio
  document.getElementById('studioCard').scrollIntoView({behavior:'smooth'});
});

/* ---------- Recording + WebAudio ---------- */
let audioContext, analyser, dataArray, sourceNode;
let mediaStream, mediaRecorder;
let chunks = [];
let recordingStart = 0;
let recordingTimer = null;
let currentSpeaker = null; // role string
let transcripts = {}; // transcripts per role
let recognition = null;
let isRecording = false;

// Setup UI references
const micBtn = $('micBig');
const micStatus = $('micStatus');
const timerPill = $('timer');
const currentSpeakerPill = $('currentSpeaker');
const recSizePill = $('recSize');
const waveCanvas = $('waveCanvas');
const waveCtx = waveCanvas.getContext('2d');

function ensureAudioSetup(){
  if(audioContext) return;
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
}

async function startMic(){
  try{
    ensureAudioSetup();
    mediaStream = await navigator.mediaDevices.getUserMedia({audio:true});
    sourceNode = audioContext.createMediaStreamSource(mediaStream);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    const bufferLength = analyser.fftSize;
    dataArray = new Uint8Array(bufferLength);
    sourceNode.connect(analyser);
    visualizeWave();
    // Setup MediaRecorder
    mediaRecorder = new MediaRecorder(mediaStream);
    mediaRecorder.ondataavailable = e => { if(e.data && e.data.size>0) chunks.push(e.data); };
    mediaRecorder.onstop = onRecordingStop;
    micStatus.innerText = 'Ready to record!';
  }catch(err){
    console.error(err);
    micStatus.innerText = 'Microphone access denied or unavailable.';
    alert('Microphone access is required. Please allow microphone permission and try again.');
  }
}

function visualizeWave(){
  const canvas = waveCanvas;
  function resize(){
    canvas.width = canvas.clientWidth * devicePixelRatio;
    canvas.height = canvas.clientHeight * devicePixelRatio;
    waveCtx.scale(devicePixelRatio, devicePixelRatio);
  }
  resize();
  window.addEventListener('resize', resize);
  function draw(){
    requestAnimationFrame(draw);
    if(!analyser) return;
    analyser.getByteTimeDomainData(dataArray);
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    waveCtx.clearRect(0,0,w,h);
    // background
    waveCtx.fillStyle = '#fff';
    waveCtx.fillRect(0,0,w,h);
    // waveform
    waveCtx.lineWidth = 2;
    waveCtx.strokeStyle = '#4b0082';
    waveCtx.beginPath();
    const slice = dataArray.length / w;
    for(let x=0;x<w;x++){
      const v = dataArray[Math.floor(x*slice)] / 128.0;
      const y = v * h/2;
      if(x===0) waveCtx.moveTo(x,y);
      else waveCtx.lineTo(x,y);
    }
    waveCtx.stroke();
  }
  draw();
}

/* ---------- SpeechRecognition (live) ---------- */
function initRecognition(){
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SR) {
    console.warn('SpeechRecognition not supported in this browser.');
    return null;
  }
  const r = new SR();
  r.lang = 'en-GB';
  r.interimResults = true;
  r.continuous = true;
  r.onresult = (ev) => {
    // collect final results into transcripts[currentSpeaker]
    for(let i = ev.resultIndex; i < ev.results.length; i++){
      const res = ev.results[i];
      const text = res[0].transcript.trim();
      if(res.isFinal){
        if(currentSpeaker){
          transcripts[currentSpeaker] = (transcripts[currentSpeaker]||'') + ' ' + text;
        } else {
          // if no speaker marked, append to a default role if exists
          const defaultRole = savedScript && savedScript.roles && savedScript.roles[0];
          if(defaultRole) transcripts[defaultRole] = (transcripts[defaultRole]||'') + ' ' + text;
        }
      } else {
        // interim: show in status
        micStatus.innerText = 'Recording (listening)â€¦';
      }
    }
  };
  r.onerror = (e) => {
    console.warn('Recognition error', e);
  };
  r.onend = () => {
    // if still recording, restart recognition to keep continuous
    if(isRecording) {
      try { r.start(); } catch(e){ /* ignore */ }
    }
  };
  return r;
}

/* ---------- Recording controls ---------- */
micBtn.addEventListener('click', async ()=>{
  if(!mediaStream) await startMic();
  if(!mediaRecorder) { micStatus.innerText = 'Microphone not ready.'; return; }
  if(mediaRecorder.state === 'recording'){
    stopRecording();
  } else {
    startRecording();
  }
});

function startRecording(){
  if(!mediaRecorder) return;
  chunks = [];
  transcripts = {};
  currentSpeaker = null;
  currentSpeakerPill.innerText = 'Current: â€”';
  recSizePill.innerText = '0 KB';
  mediaRecorder.start();
  isRecording = true;
  recordingStart = Date.now();
  micBtn.classList.add('recording');
  micBtn.innerText = 'â¹';
  micStatus.innerText = 'Recording: 00:00';
  // timer
  recordingTimer = setInterval(()=>{
    const s = Math.floor((Date.now()-recordingStart)/1000);
    timerPill.innerText = formatTime(s);
    micStatus.innerText = 'Recording: ' + formatTime(s);
  }, 500);
  // start recognition
  recognition = initRecognition();
  if(recognition) {
    try { recognition.start(); } catch(e){ /* ignore */ }
  }
}

function stopRecording(){
  if(mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
  isRecording = false;
  micBtn.classList.remove('recording');
  micBtn.innerText = 'ðŸŽ¤';
  clearInterval(recordingTimer);
  timerPill.innerText = formatTime(Math.floor((Date.now()-recordingStart)/1000));
  micStatus.innerText = 'Processing recording...';
  if(recognition){
    try { recognition.stop(); } catch(e){ /* ignore */ }
    recognition = null;
  }
}

async function onRecordingStop(){
  // create blob and dataURL for storage/playback
  const blob = new Blob(chunks, { type: 'audio/webm' });
  const sizeKB = Math.round(blob.size/1024);
  recSizePill.innerText = `${sizeKB} KB`;
  micStatus.innerText = 'Recording saved locally (preview ready).';
  // convert to base64 dataURL
  const dataURL = await blobToDataURL(blob);
  // store current session in memory for quick play
  lastSession = {
    blob, dataURL, duration: Math.floor((Date.now()-recordingStart)/1000),
    transcripts: JSON.parse(JSON.stringify(transcripts)),
    scriptTitle: savedScript ? savedScript.title : 'Untitled'
  };
  // update play button availability
  $('playRec').disabled = false;
  $('downloadRec').disabled = false;
}

/* helper */
function blobToDataURL(blob){
  return new Promise((res,rej)=>{
    const fr = new FileReader();
    fr.onload = ()=>res(fr.result);
    fr.onerror = rej;
    fr.readAsDataURL(blob);
  });
}

/* ---------- Speaker marking ---------- */
$('markA').addEventListener('click', ()=>setSpeakerByIndex(0));
$('markB').addEventListener('click', ()=>setSpeakerByIndex(1));
function setSpeakerByIndex(i){
  if(!savedScript){ alert('Please save a script first so speakers are known.'); return; }
  const role = savedScript.roles[i] || savedScript.roles[0];
  currentSpeaker = role;
  currentSpeakerPill.innerText = 'Current: ' + role;
  // ensure transcripts entry exists
  transcripts[role] = transcripts[role] || '';
}

/* ---------- Re-record / Play / Download ---------- */
let lastSession = null;
$('reRecord').addEventListener('click', ()=>{
  // clear lastSession and allow re-record
  lastSession = null;
  chunks = [];
  transcripts = {};
  micStatus.innerText = 'Ready to record!';
  timerPill.innerText = '00:00';
  recSizePill.innerText = '0 KB';
});
$('playRec').addEventListener('click', ()=>{
  if(!lastSession){ alert('No recording available. Record a session first.'); return; }
  const a = new Audio(lastSession.dataURL);
  a.play();
});
$('downloadRec').addEventListener('click', ()=>{
  if(!lastSession){ alert('No recording available.'); return; }
  const a = document.createElement('a');
  a.href = lastSession.dataURL;
  a.download = (savedScript ? savedScript.title.replace(/\s+/g,'_') : 'recording') + '.webm';
  a.click();
});

/* ---------- Analysis ---------- */
/* Compare transcripts per role to saved script lines for that role.
   Simple algorithm:
   - Join saved lines for role into a reference string.
   - Tokenize both reference and transcript into words (lowercase, strip punctuation).
   - Count words present in transcript; compute accuracy = matched / totalRefWords.
   - List words from reference not found in transcript as "incorrect".
*/
function tokenize(s){
  return s.toLowerCase().replace(/[^\w\s']/g,'').split(/\s+/).filter(Boolean);
}

$('analyzeBtn').addEventListener('click', analyzeNow);

function analyzeNow(){
  if(!savedScript){ alert('Please save a script first.'); return; }
  if(!lastSession){ alert('No recording available. Record a session first.'); return; }
  // For each role in savedScript.roles compute score
  const results = {};
  let totalMatched = 0, totalRef = 0;
  savedScript.roles.forEach(role=>{
    const refLines = (savedScript.linesByRole[role] || []).join(' ');
    const refTokens = tokenize(refLines);
    const transcript = (lastSession.transcripts && lastSession.transcripts[role]) ? lastSession.transcripts[role] : '';
    const transTokens = tokenize(transcript);
    const transSet = new Set(transTokens);
    const incorrect = [];
    let matched = 0;
    refTokens.forEach(w=>{
      if(transSet.has(w)) matched++;
      else incorrect.push(w);
    });
    const score = refTokens.length ? Math.round((matched / refTokens.length) * 100) : 0;
    results[role] = {score, incorrect: Array.from(new Set(incorrect)).slice(0,60)};
    totalMatched += matched;
    totalRef += refTokens.length;
  });
  const combined = totalRef ? Math.round((totalMatched/totalRef)*100) : 0;
  // Update UI
  const roleA = savedScript.roles[0] || 'Student A';
  const roleB = savedScript.roles[1] || (savedScript.roles[0] ? savedScript.roles[0] : 'Student B');
  $('scoreA').innerText = results[roleA] ? results[roleA].score + '%' : 'â€”';
  $('scoreB').innerText = results[roleB] ? results[roleB].score + '%' : 'â€”';
  $('scoreCombined').innerText = combined + '%';
  // show incorrect words as clickable for TTS
  const mkWords = (arr, containerId) => {
    const el = $(containerId);
    el.innerHTML = '';
    if(!arr || arr.length===0){ el.innerHTML = '<div class="muted">No major mismatches detected.</div>'; return; }
    arr.forEach(w=>{
      const span = document.createElement('span');
      span.className = 'word';
      span.innerText = w;
      span.onclick = ()=>speakUK(w);
      el.appendChild(span);
    });
  };
  mkWords(results[roleA] ? results[roleA].incorrect : [], 'missA');
  mkWords(results[roleB] ? results[roleB].incorrect : [], 'missB');
  // Save to library
  saveSessionToLibrary({
    title: lastSession.scriptTitle || (savedScript ? savedScript.title : 'Untitled'),
    date: new Date().toLocaleString(),
    duration: lastSession.duration || 0,
    scores: savedScript.roles.map(r => results[r] ? results[r].score : 0),
    combined,
    dataURL: lastSession.dataURL
  });
  // show combined words clickable in combined area (merge both incorrect lists)
  const combinedIncorrect = [];
  savedScript.roles.forEach(r=>{
    const arr = results[r] ? results[r].incorrect : [];
    arr.forEach(w=>{ if(!combinedIncorrect.includes(w)) combinedIncorrect.push(w); });
  });
  const combinedEl = $('analysisCombined');
  // append clickable words below combined score
  let wordsHtml = '<div style="margin-top:10px">';
  if(combinedIncorrect.length===0) wordsHtml += '<div class="muted">No mismatched words.</div>';
  else combinedIncorrect.slice(0,80).forEach(w => wordsHtml += `<span class="word" onclick="speakUK('${escapeHtml(w)}')">${escapeHtml(w)}</span>`);
  wordsHtml += '</div>';
  // inject
  const sc = $('scoreCombined');
  sc.insertAdjacentHTML('afterend', wordsHtml);
}

/* TTS UK voice */
function speakUK(text){
  try{
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'en-GB';
    // try to pick a UK voice if available
    const voices = speechSynthesis.getVoices();
    const uk = voices.find(v => /en-?gb|english.*uk/i.test(v.lang) || /uk/i.test(v.name));
    if(uk) u.voice = uk;
    u.rate = 0.95;
    speechSynthesis.speak(u);
  }catch(e){ console.warn('TTS error', e); }
}

/* ---------- Library (LocalStorage) ---------- */
function saveSessionToLibrary(item){
  // item: {title,date,duration,scores:[],combined,dataURL}
  const key = 'roleplayconvo_recordings_v1';
  const arr = JSON.parse(localStorage.getItem(key) || '[]');
  arr.unshift(item); // newest first
  // keep max 80
  if(arr.length>80) arr.length = 80;
  localStorage.setItem(key, JSON.stringify(arr));
  renderLibrary();
}

function renderLibrary(){
  const key = 'roleplayconvo_recordings_v1';
  const arr = JSON.parse(localStorage.getItem(key) || '[]');
  const list = $('libraryList');
  list.innerHTML = '';
  if(arr.length===0){
    list.innerHTML = '<div class="muted">No recordings yet. Record a session to see it here.</div>';
    return;
  }
  arr.forEach((it, idx)=>{
    const div = document.createElement('div');
    div.className = 'lib-item';
    const meta = document.createElement('div');
    meta.className = 'lib-meta';
    meta.innerHTML = `<div style="font-weight:700">${escapeHtml(it.title)}</div>
                      <div class="pill">${escapeHtml(it.date)}</div>
                      <div class="pill">${formatTime(it.duration)}</div>
                      <div class="pill">A: ${it.scores[0] ?? 'â€”'}%</div>
                      <div class="pill">B: ${it.scores[1] ?? 'â€”'}%</div>
                      <div class="pill">Combined: ${it.combined}%</div>`;
    const actions = document.createElement('div');
    actions.className = 'lib-actions';
    const play = document.createElement('button');
    play.className = 'control-btn small';
    play.innerText = 'Play';
    play.onclick = ()=>{ const a = new Audio(it.dataURL); a.play(); };
    const analyze = document.createElement('button');
    analyze.className = 'control-btn small';
    analyze.innerText = 'Analyze';
    analyze.onclick = ()=>{ // load this session into lastSession and show analysis
      lastSession = { dataURL: it.dataURL, duration: it.duration, transcripts: {} };
      // we cannot reconstruct transcripts from stored item; show stored scores
      $('scoreA').innerText = it.scores[0] + '%';
      $('scoreB').innerText = it.scores[1] + '%';
      $('scoreCombined').innerText = it.combined + '%';
      $('missA').innerHTML = '<div class="muted">Detailed mismatches not saved for this session.</div>';
      $('missB').innerHTML = '<div class="muted">Detailed mismatches not saved for this session.</div>';
      window.scrollTo({top:0,behavior:'smooth'});
    };
    const del = document.createElement('button');
    del.className = 'control-btn small';
    del.style.background = '#ffefef';
    del.style.color = '#b00000';
    del.innerText = 'Delete';
    del.onclick = ()=>{
      if(!confirm('Delete this recording?')) return;
      arr.splice(idx,1);
      localStorage.setItem(key, JSON.stringify(arr));
      renderLibrary();
    };
    actions.appendChild(play);
    actions.appendChild(analyze);
    actions.appendChild(del);
    div.appendChild(meta);
    div.appendChild(actions);
    list.appendChild(div);
  });
}

/* ---------- Helpers ---------- */
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

/* ---------- Init / UI wiring ---------- */
$('startBtn').addEventListener('click', ()=>{ document.getElementById('studioCard').scrollIntoView({behavior:'smooth'}); });
$('viewLibBtn').addEventListener('click', ()=>{ document.getElementById('libraryCard').scrollIntoView({behavior:'smooth'}); renderLibrary(); });

window.addEventListener('load', ()=>{
  // prepare audio context on first user gesture for mobile autoplay policies
  document.body.addEventListener('click', function initOnce(){
    ensureAudioSetup();
    document.body.removeEventListener('click', initOnce);
  });
  renderLibrary();
  // disable play/download until a recording exists
  $('playRec').disabled = false; // allow playing library items; lastSession may be null
});

/* ---------- Accessibility / mobile touches ---------- */
/* Fullscreen recording mode on long-press mic (mobile) */
let pressTimer = null;
micBtn.addEventListener('touchstart', (e)=>{
  pressTimer = setTimeout(()=>{ // enter fullscreen
    if(document.fullscreenEnabled){
      document.documentElement.requestFullscreen().catch(()=>{});
    }
  }, 700);
});
micBtn.addEventListener('touchend', ()=>{ clearTimeout(pressTimer); });

/* End of script */
</script>
</body>
</html>
